################################################################################
#
#   MRC FGU Computational Genomics Group
#
#   $Id: pipeline_rnaseq_geneset.py 2900 2012-03-38 14:38:00Z david $
#
#   Copyright (C) 2012 David Sims
#
#   This program is free software; you can redistribute it and/or
#   modify it under the terms of the GNU General Public License
#   as published by the Free Software Foundation; either version 2
#   of the License, or (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#################################################################################
"""
========================
RNAseq Geneset Pipeline
========================

:Author: David Sims 
:Release: $Id: pipeline_rnaseq_genesst.py 2900 2012-03-28 14:38:00Z david $
:Date: |today|
:Tags: Python

The RNAseq geneset pipeline parses multiple GTF files derived from RNAseq experiments in different tissues and produces a consensus geneset

Usage
=====

See :ref:`PipelineSettingUp` and :ref:`PipelineRunning` on general information how to use CGAT pipelines.

Configuration
-------------

The pipeline requires a configured :file:`pipeline.ini` file. 

Configuration files follow the ini format (see the python
`ConfigParser <http://docs.python.org/library/configparser.html>` documentation).
The configuration file is organized by section and the variables are documented within 
the file. In order to get a local configuration file in the current directory, type::

    python <codedir>/pipeline_rnaseq_genest.py config

The sphinxreport report requires a :file:`conf.py` and :file:`sphinxreport.ini` file 
(see :ref:`PipelineDocumenation`). To start with, use the files supplied with the
:ref:`Example` data.


Input
-----

Input are GTF-formatted files. 

Requirements
------------

The pipeline requires the information from the following pipelines:

:doc:`pipeline_annotations`

set the configuration variables:
   :py:data:`annotations_database` 
   :py:data:`annotations_dir`

On top of the default CGAT setup, the pipeline requires the following software to be in the 
path:

+--------------------+-------------------+------------------------------------------------+
|*Program*           |*Version*          |*Purpose*                                       |
+--------------------+-------------------+------------------------------------------------+
|BEDTools            |                   |interval comparison                             |
+--------------------+-------------------+------------------------------------------------+


Pipline Output
==============

The results of the computation are all stored in an sqlite relational
database :file:`csvdb`.


Code
====

"""
import sys, tempfile, optparse, shutil, itertools, csv, math, random, re, glob, os, shutil, collections, gzip
import sqlite3
import pysam
import IndexedFasta, IndexedGenome, FastaIterator, Genomics
import IOTools
import MAST, GTF, GFF, Bed
import cStringIO
import numpy
import Masker
import fileinput
import Experiment as E
import logging as L
from ruffus import *

USECLUSTER = True

###################################################
###################################################
###################################################
## Pipeline configuration
###################################################
import Pipeline as P
P.getParameters(  ["pipeline.ini", ] )
PARAMS = P.PARAMS
#PARAMS_ANNOTATIONS = P.peekParameters( PARAMS["geneset_dir"],"pipeline_annotations.py" )

###################################################
## Parse GTF file
@follows( mkdir("exons") )
@transform( "*.gtf", regex(r"(\S+).gtf"), r"exons/\1.exons.tab" )
def getGTFexons( infile, outfile ):
    '''Copy replicated Bed files generated by capseq pipline to geneset-specific output directory'''
    track = P.snip( os.path.basename(infile), ".gtf" )
    species, tissue = track.split("-")
    statement = '''cat %(infile)s | grep "exon" | python %(scriptsdir)s/gtf2tab.py -f --log=%(outfile)s.log | awk '{if (NR==1) {print $0"\\tTissue"} else {$0"\\t%(tissue)s"}}' > %(outfile)s'''
    P.run()

###################################################
@merge(getGTFexons, "exons/all_tissues.exons.tab")
def mergeExonListsAcrossTissues( infiles, outfile ):
    '''merge GTF files from all species'''
    inlist = " ".join(infiles)
    statement = ''' cat %(inlist)s | awk '{if ($1!="contig" || NR==1) {print}}' > %(outfile)s;'''
    P.run()
    
###################################################
@transform( mergeExonListsAcrossTissues, suffix(".exons.tab"), ".exons.tab.load" )
def loadExons( infile, outfile ):
    '''load GTF file into database '''
    headers = "contig,source,feature,start,end,score,strand,frame,gene_id,transcript_id,"
    statement = """cat %(infile)s | python ~/src/csv2db.py 
                         --database=%(database)s
                         --table=exons
                         --index=gene_id
                         --index=contig,start
                         --index=transcript_id
                 > %(outfile)s; """
    P.run()

###################################################
###################################################        
###################################################
## Parse transcripts from GTF file
@follows( mkdir("transcripts") )
@transform( "*.gtf", regex(r"(\S+).gtf"), r"transcripts/\1.transcripts.gtf" )
def getGtfStrandedTranscripts( infile, outfile ):
    '''get transcripts from GTF file and convert to tab-delimited table for database upload'''
    track = P.snip( os.path.basename(infile), ".gtf" )
    species, tissue = track.split("-")
    statement = '''cat %(infile)s | awk '$3 == "transcript"' | awk '$7 != "."' > %(outfile)s'''
    P.run()

###################################################
@merge(getGtfStrandedTranscripts, "transcripts/all_tissues.transcripts.gtf")
def mergeGtfTranscripts( infiles, outfile ):
    '''merge GTF files from all species'''
    inlist = " ".join(infiles)
    statement = ''' cat %(inlist)s | sort -k1,1 -k4,2 > %(outfile)s;'''
    P.run()

###################################################
@transform(mergeGtfTranscripts, regex("(\S+).transcripts.gtf"), "transcripts/all_tissues.transcripts.dedup.gtf")
def removeDuplicateTranscripts( infile, outfile ):
    '''Remove duplicate transcripts from merged GTF file'''
    statement = '''cat %(infile)s | 
                   python %(scriptsdir)s/gtf2gtf.py --remove-duplicates=coordinates --log=%(outfile)s.log 
                   > %(outfile)s'''
    P.run()
    
###################################################
@transform( removeDuplicateTranscripts, suffix(".gtf"), ".coding.gtf")
def getEnsemblCodingGeneset( infile, outfile ):
    '''identify transcrpts that overlap an ensembl coding gene '''
    ensembl_genes = PARAMS["ensembl_genes"]
    statement = '''cat %(infile)s | intersectBed -a stdin -b %(ensembl_genes)s -u -s > %(outfile)s;
                   echo "transcripts with ensembl coding overlap: " > %(outfile)s.count; 
                   cat %(outfile)s | wc -l >> %(outfile)s.count;
                   echo "transcripts with ensembl coding overlap and no ensembl annotation: " >> %(outfile)s.count;
                   cat %(outfile)s | grep -v "ENSACA" | wc -l >> %(outfile)s.count;'''
    P.run()

###################################################
@transform( getEnsemblCodingGeneset, suffix(".gtf"), ".rename.gtf")
def renameTranscripts( infile, outfile ):
    '''systenatically rename transcripts to remove duplicate cuffdiff names '''
    statement = '''cat %(infile)s | awk 'OFS="\\t" {print $1,$2,$3,$4,$5,$6,$7,$8,"transcript_id \\"rnaseq_coding_transcript_"NR"\\"; "}' > %(outfile)s;'''
    P.run()
    
###################################################
@transform(renameTranscripts, suffix(".gtf"), ".ensg.gtf" )
def annotateTranscripts( infile, outfile ):
    ''' Add ensembl gene id to GTF file'''
    ensembl_genes = PARAMS["ensembl_genes"]
    statement = '''cat %(infile)s 
                   | intersectBed -a stdin -b %(ensembl_genes)s -wa -wb -s 
                   | awk 'FS="\\t", OFS="\\t" {print $1,$2,$3,$4,$5,$6,$7,$8,$9"gene_id \\""$13"\\"; "}'
                   | python %(scriptsdir)s/gtf2gtf.py --remove-duplicates=coordinates --log=%(outfile)s.log
                   > %(outfile)s;'''
    P.run()
    
###################################################
@transform(annotateTranscripts, regex(r"transcripts/(\S+).ensg.gtf"), r"transcripts/all_transcripts.gtf" )
def addMissingEnsemblTranscripts( infile, outfile ):
    ''' Add ensembl gene id to GTF file'''
    ensembl_transcripts = PARAMS["ensembl_transcripts"]
    statement = '''cat %(infile)s 
                   | intersectBed -a %(ensembl_transcripts)s -b stdin -v -s -f 1 -r
                   | python %(scriptsdir)s/bed2gff.py --as-gtf --log=%(outfile)s.log 
                   > transcripts/missing_ensembl_transcripts.gtf;
                   cat %(infile)s transcripts/missing_ensembl_transcripts.gtf | sort -k1,1 -k4,2 
                   > %(outfile)s;'''
    P.run()

###################################################
###################################################    
###################################################
## Non-coding
@transform( removeDuplicateTranscripts, suffix(".gtf"), ".noncoding.gtf")
def getNoncodingGeneset( infile, outfile ):
    '''Assume that all transcripts the do not overlap with ensembl coding geneset are noncoding '''
    ensembl_transcripts = PARAMS["ensembl_transcripts"]
    statement = '''cat %(infile)s | intersectBed -a stdin -b %(ensembl_transcripts)s -v -s > %(outfile)s;
                   echo "transcripts without ensembl coding overlap: " > %(outfile)s.count; 
                   cat %(outfile)s | wc -l >> %(outfile)s.count;'''
    P.run()
    
###################################################
@transform( getNoncodingGeneset, suffix(".gtf"), ".rename.gtf")
def renameNoncodingTranscripts( infile, outfile ):
    '''systenatically rename transcripts to remove duplicate cuffdiff names '''
    statement = '''cat %(infile)s | awk 'OFS="\\t" {print $1,$2,$3,$4,$5,$6,$7,$8,"transcript_id \\"rnaseq_noncoding_transcript_"NR"\\"; "}' > %(outfile)s;'''
    P.run()
    
###################################################
@transform(renameNoncodingTranscripts, suffix(".gtf"), ".ensg.gtf" )
def annotateNoncodingTranscripts( infile, outfile ):
    ''' Add ensembl gene id to GTF file'''
    ensembl_noncoding = PARAMS["ensembl_noncoding"]
    statement = '''intersectBed -a %(infile)s  -b %(ensembl_noncoding)s -wa -wb -s 
                   | awk 'FS="\\t", OFS="\\t" {print $1,$2,$3,$4,$5,$6,$7,$8,$9"gene_id \\""$13"\\"; "}'
                   | python %(scriptsdir)s/gtf2gtf.py --remove-duplicates=coordinates --log=%(outfile)s.log
                   > transcripts/known_noncoding_exons.gtf;  
                   intersectBed -a %(infile)s -b %(ensembl_noncoding)s -v -s
                   | awk 'FS="\\t", OFS="\\t" {print $1,$2,$3,$4,$5,$6,$7,$8,$9"gene_id \\"novel_gene_"NR"\\"; "}'
                   > transcripts/novel_noncoding_transcripts.gtf; 
                   cat transcripts/known_noncoding_exons.gtf transcripts/novel_noncoding_transcripts.gtf 
                   | sort -k1,1 -k4,2 
                   > %(outfile)s;'''
    P.run()
    
###################################################
@transform(annotateNoncodingTranscripts, regex(r"transcripts/(\S+).ensg.gtf"), r"transcripts/all_noncoding_transcripts.gtf" )
def addMissingNoncodingTranscripts( infile, outfile ):
    ''' Add ensembl gene id to GTF file'''
    ensembl_noncoding = PARAMS["ensembl_noncoding"]
    statement = '''intersectBed -a %(ensembl_noncoding)s -b %(infile)s  -v -s -f 1 -r
                   | python %(scriptsdir)s/bed2gff.py --as-gtf --log=%(outfile)s.log 
                   > transcripts/missing_ensembl_noncoding_transcripts.gtf;
                   cat %(infile)s transcripts/missing_ensembl_noncoding_transcripts.gtf  
                   | sort -k1,1 -k4,2 
                   > %(outfile)s;'''
    P.run()

###################################################
###################################################
###################################################
## create input files for CAPseq interval annotation pipeline
@follows( mkdir("geneset") )
@transform(getEnsemblCodingGeneset, regex(r"transcripts/(\S+).ensembl.gtf"), r"geneset/\1.genes.bed" )
def buildGeneIntervals( infile, outfile ):
    ''' Merge all transcripts per gene (including utr) to get start and stop 
        coordinates for every protein-coding gene and store in a GTF file'''

    statement = '''mergeBed -i %(infile)s -s -n 
                   | awk 'OFS="\\t" {print $1,$2,$3,"gene"NR,$4,$5 }'
                   > %(outfile)s;'''
    P.run()

###################################################
@transform(buildGeneIntervals, regex(r"geneset/(\S+).genes.bed"), r"geneset/\1.ensembl.genes.bed" )
def annotateGeneIntervals( infile, outfile ):
    ''' Add ensembl gene id to GTF file'''
    ensembl_genes = PARAMS["ensembl_genes"]
    statement = '''cat %(infile)s 
                   | intersectBed -a stdin -b %(ensembl_genes)s -wa -wb -s 
                   | awk 'OFS="\\t" {print $1,$2,$3,$10,$5,$6}'
                   | python %(scriptsdir)s/bed2gff.py --as-gtf --log=%(outfile)s.log
                   | sort -k1,1 -k4,2
                   | python %(scriptsdir)s/gtf2gtf.py --remove-duplicates=coordinates --log=%(outfile)s.log 
                   | python %(scriptsdir)s/gff2bed.py --is-gtf --name=gene_id --log=%(outfile)s.log 
                   > %(outfile)s;'''
    P.run()
    
###################################################
@transform(annotateGeneIntervals, regex(r"geneset/(\S+).ensembl.genes.bed"), os.path.join("geneset", PARAMS['interface_genic_bed']) )
def addMissingEnsemblGenes( infile, outfile ):
    ''' Add ensembl gene id to GTF file'''
    ensembl_genes = PARAMS["ensembl_genes"]
    statement = '''cat %(infile)s 
                   | intersectBed -a %(ensembl_genes)s -b stdin -v -s   
                   > geneset/missing_ensembl_genes.bed;
                   cat %(infile)s geneset/missing_ensembl_genes.bed | sort -k1,1 -k2,2 
                   > %(outfile)s;'''
    P.run()

############################################################
@transform(addMissingEnsemblGenes, regex(PARAMS['interface_genic_bed']), PARAMS['interface_upstream_flank_bed'] )
def buildUpstreamFlankBed( infile, outfile ):
    ''' build interval upstream of gene start for each entry in bed file'''

    window=PARAMS["geneset_flank"]
    faidx=PARAMS["faidx"]

    statement = '''flankBed -i %(infile)s -g %(faidx)s -l %(window)s -r 0 -s 
                   | python %(scriptsdir)s/bed2bed.py --method=filter-genome --genome-file=%(genome_dir)s/%(genome)s --log %(outfile)s.log > %(outfile)s'''
    P.run()

############################################################
@transform(addMissingEnsemblGenes, regex(PARAMS['interface_genic_bed']), PARAMS['interface_downstream_flank_bed'] )
def buildDownstreamFlankBed( infile, outfile ):
    ''' build interval downstream of gene start for each entry in bed file'''

    window=PARAMS["geneset_flank"]
    faidx=PARAMS["faidx"]

    statement = '''flankBed -i %(infile)s -g %(faidx)s -l 0 -r %(window)s -s 
                   | python %(scriptsdir)s/bed2bed.py --method=filter-genome --genome-file=%(genome_dir)s/%(genome)s --log %(outfile)s.log > %(outfile)s'''
    P.run()

############################################################
@merge((addMissingEnsemblGenes, buildUpstreamFlankBed, buildDownstreamFlankBed), os.path.join("geneset",PARAMS['interface_intergenic_bed']) )
def buildIntergenicBed( infiles, outfile ):
    ''' Genomic regions not associated with any other features'''
    inlist = " ".join(infiles)

    statement = '''cat %(inlist)s | complementBed -i stdin -g %(faidx)s > %(outfile)s'''
    P.run()

############################################################
@transform((addMissingEnsemblGenes,buildUpstreamFlankBed,buildDownstreamFlankBed,buildIntergenicBed), suffix(".bed"), ".gtf" )
def convertBedToGtf( infile, outfile ):
    ''' convert bed files to GTF'''

    statement = '''cat %(infile)s | python %(scriptsdir)s/bed2gff.py --as-gtf | grep -v "#" > %(outfile)s'''
    P.run()

############################################################
############################################################
############################################################
## TRANSCRIPTION START SITES
@transform(addMissingEnsemblTranscripts, regex(r"transcripts/all_transcripts.gtf"), os.path.join("geneset",PARAMS["interface_tss_bed"]) )
def buildTranscriptTSS( infile, outfile ):
    '''annotate transcription start sites from reference gene set.
    Similar to promotors, except that the witdth is set to 1. '''
    statement = """
        cat < %(infile)s 
        | python %(scriptsdir)s/gff2gff.py --sanitize=genome --skip-missing --genome-file=%(genome_dir)s/%(genome)s --log=%(outfile)s.log  
        | python %(scriptsdir)s/gtf2gff.py --method=promotors --promotor=1 --genome-file=%(genome_dir)s/%(genome)s --log=%(outfile)s.log 
        | python %(scriptsdir)s/gff2bed.py --is-gtf --name=transcript_id --log=%(outfile)s.log 
        | python %(scriptsdir)s/bed2bed.py --method=filter-genome --genome-file=%(genome_dir)s/%(genome)s --log %(outfile)s.log
        | gzip
        > %(outfile)s """
    P.run()

############################################################
@follows( convertBedToGtf )
@files( "genes.gtf", PARAMS["interface_tss_gene_bed"] )
def buildGeneTSS( infile, outfile ):
    '''create a single TSS for each gene'''
    statement = """
        cat %(infile)s 
        | python %(scriptsdir)s/gff2gff.py --sanitize=genome --skip-missing --genome-file=%(genome_dir)s/%(genome)s --log=%(outfile)s.log 
        | python %(scriptsdir)s/gtf2gff.py --method=promotors --promotor=1 --genome-file=%(genome_dir)s/%(genome)s --log=%(outfile)s.log 
        | python %(scriptsdir)s/gff2bed.py --is-gtf --name=gene_id --log=%(outfile)s.log 
        | python %(scriptsdir)s/bed2bed.py --method=filter-genome --genome-file=%(genome_dir)s/%(genome)s --log %(outfile)s.log
        | gzip
        > %(outfile)s """
    P.run()
    
############################################################
@transform( addMissingEnsemblTranscripts, regex(r"transcripts/all_transcripts.gtf"), os.path.join("geneset",PARAMS["interface_tss_gene_interval_bed"]) )
def buildGeneTSSInterval( infile, outfile ):
    '''create a single interval that encompasses all annotated TSSs for a given gene'''
    statement = """
        cat < %(infile)s 
        | python %(scriptsdir)s/gff2gff.py --sanitize=genome --skip-missing --genome-file=%(genome_dir)s/%(genome)s --log=%(outfile)s.log 
        | python %(scriptsdir)s/gtf2gff.py --method=promotors --promotor=1 --genome-file=%(genome_dir)s/%(genome)s --log=%(outfile)s.log 
        | sed s/\\\\ttranscript\\\\t/\\\\texon\\\\t/g 
        | python %(scriptsdir)s/gtf2gtf.py --merge-transcripts --log=%(outfile)s.log 
        | python %(scriptsdir)s/gff2bed.py --is-gtf --name=transcript_id --log=%(outfile)s.log 
        | python %(scriptsdir)s/bed2bed.py --method=filter-genome --genome-file=%(genome_dir)s/%(genome)s --log %(outfile)s.log
        | gzip
        > %(outfile)s """
    P.run()
    
############################################################
@transform( addMissingNoncodingTranscripts, regex(r"(\S+).gtf"), PARAMS["interface_tss_gene_noncoding_bed"] )
def buildNoncodingGeneTSS( infile, outfile ):
    '''Assign a TSS for each non-coding gene'''
    statement = """
        cat < %(infile)s 
        | python %(scriptsdir)s/gff2gff.py --sanitize=genome --skip-missing --genome-file=%(genome_dir)s/%(genome)s --log=%(outfile)s.log 
        | python %(scriptsdir)s/gtf2gff.py --method=promotors --promotor=1 --genome-file=%(genome_dir)s/%(genome)s --log=%(outfile)s.log 
        | python %(scriptsdir)s/gff2bed.py --is-gtf --name=gene_id --log=%(outfile)s.log 
        | python %(scriptsdir)s/bed2bed.py --method=filter-genome --genome-file=%(genome_dir)s/%(genome)s --log %(outfile)s.log
        | gzip
        > %(outfile)s """
    P.run()
    
############################################################
@transform( (buildTranscriptTSS, buildGeneTSS, buildGeneTSSInterval, buildNoncodingGeneTSS), suffix(".bed.gz"), ".extended.bed.gz" )
def ExtendRegion( infile, outfile ):
    '''convert bed to gtf'''
    statement = """gunzip < %(infile)s 
                   | slopBed -i stdin -g %(faidx)s -b 1000  
                   | gzip
                   > %(outfile)s """
    P.run()
    
############################################################
@transform( (buildTranscriptTSS, buildGeneTSS, buildGeneTSSInterval, buildNoncodingGeneTSS, ExtendRegion), suffix(".bed.gz"), ".gtf" )
def convertToGTF( infile, outfile ):
    '''convert bed to gtf'''
    statement = """gunzip < %(infile)s 
                   | python %(scriptsdir)s/bed2gff.py --as-gtf  --log=%(outfile)s.log 
                   > %(outfile)s """
    P.run()
        
############################################################
############################################################
############################################################

@follows( getGTFexons, mergeExonListsAcrossTissues, loadExons )
def exons():
    '''build all targets.'''
    pass

@follows( getGtfStrandedTranscripts, mergeGtfTranscripts, removeDuplicateTranscripts,
          getEnsemblCodingGeneset, getNoncodingGeneset )
def transcripts():
    '''build all targets.'''
    pass
  
@follows( buildGeneIntervals, addMissingEnsemblGenes, buildUpstreamFlankBed,
          buildDownstreamFlankBed, buildIntergenicBed, convertBedToGtf )
def genes():
    '''build all targets.'''
    pass  

@follows( buildTranscriptTSS, buildGeneTSS, buildNoncodingGeneTSS,
          ExtendRegion, convertToGTF )
def tss():
    '''build all targets.'''
    pass 

@follows( exons, transcripts, genes, tss )
def full():
    '''build all targets.'''
    pass 


if __name__== "__main__":
    sys.exit( P.main(sys.argv) )
    
