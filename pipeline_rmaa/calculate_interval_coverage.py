#!/home/belgardt/bin/python2.6

# Given a list of features, chromosome sizes, and a wig file of coverage, calculates genomic and transriptomic coverage by several metrics

# Input 1: Output file of make_intervals.py giving mutually exclusive regions of genomic features.  Fills in the remainder as 'intergenic'
# Input 2: Chromosome sizes file (chrom name <tab> size)
# Input 3: Wig file of coverage, as generated by samtools pileup

# Output: Bunches of summary stats and files of coverage distributions

from sys import argv
from nested_dict import *
from operator import mul

genomic_features_file = open(argv[1],'r')
chrom_sizes_file = open(argv[2],'r')
wig_file = open(argv[3],'r')
output_base_name = argv[4]

# Get chrom sizes
chrom_sizes = {}
for line in chrom_sizes_file:
    la = line.rstrip('\n').split('\t')
    chrom_sizes[la[0]] = int( la[1] )

# Read genomic features into memory and tally the length of each class!
genomic_features = {}
lengths = {}
present_chroms = set([])
for line in genomic_features_file:
    la = line.rstrip('\n').split('\t')
    genomic_features[ la[0] ] = genomic_features.get( la[0], [] )
    genomic_features[ la[0] ].append( (int(la[1]),int(la[2]),la[3]) )
    lengths[la[3]] = lengths.get( la[3], 0 )
    lengths[la[3]] += (int(la[2]) - int(la[1]))
    present_chroms.add(la[0])
lengths["intergenic"] = 0
other_lengths=sum(lengths.values())
for chrom in list(present_chroms):
    lengths["intergenic"] += chrom_sizes[chrom]
lengths["intergenic"] -= other_lengths

def write_intergenic(feature_dists, coverage):
    feature_dists["intergenic"][coverage] = feature_dists["intergenic"].get(coverage, 0)
    feature_dists["intergenic"][coverage] += 1
    return feature_dists

# Iterate through wig file.  For those chroms for which we have feature information, add to a coverage distribution from each feature type
feature_dists = nested_dict()
for line in wig_file:
    la = line.rstrip('\n').split('\t')
    if len(la) == 1:
        la = line.rstrip('\n').split(' ')
        if la[0] == "variableStep":
            chrom = la[1].split('=')[1]
            continue
        else:
            print "Something bad wrong"
    elif not chrom in genomic_features.keys():
        continue
    if len(genomic_features[chrom]) == 0:   # if we have run out of regions, count as intergenic
        feature_dists = write_intergenic(feature_dists, int(la[1]))
    elif genomic_features[chrom][0][1] <= int(la[0]): # if this is above our current region, remove regions until we get to this position
        while genomic_features[chrom][0][1] < int(la[0]):
            genomic_features[chrom].pop(0)
            if len(genomic_features[chrom]) == 0:
                feature_dists = write_intergenic(feature_dists, int(la[1]))
                break
    elif genomic_features[ chrom ][0][0] <= int(la[0]) < genomic_features[chrom][0][1]: # if this is the proper region, count as the region and carry on
        feature_dists[genomic_features[chrom][0][2]][int(la[1])] = feature_dists[genomic_features[chrom][0][2]].get(int(la[1]), 0)
        feature_dists[genomic_features[chrom][0][2]][int(la[1])] += 1
    elif genomic_features[chrom][0][0] > int(la[0]): # if this is below our current region, count as intergenic and continue
        feature_dists = write_intergenic(feature_dists, int(la[1]))
    else:
        print "This shouldn't happen.  Check!"
        print la
        print genomic_features[chrom][0]

# Calculate summary stats
print "feature\t# sequenced bases overlapping\t# sequenced bases total\t% sequenced bases total\t# covered bases\t# bases\t% bases covered\taverage fold coverage of covered bases\t% bases above 0.1 RPKM\t% bases above 1 RPKM\t% bases above 10 RPKM\t% bases above 100 RPKM\t% bases above 1000 RPKM"
total_bases_sequenced = 0; total_genic_bases = 0
features = feature_dists.keys()
num_sequenced_bases = {}; num_covered_bases = {}
for feature in features:
    num_sequenced_bases[feature] = sum( map(lambda (x, y): mul(int(x),int(y)), feature_dists[feature].items()) )
    total_bases_sequenced += num_sequenced_bases[feature]
    num_covered_bases[feature] = sum(feature_dists[feature].values())

def filter_count_RPKM(f_distribution, total_bases_sequenced, min_rpkm):
    num_good = 0
    for cov in f_distribution.iterkeys():
        if (float(cov)*1000000.0/total_bases_sequenced/0.001) > min_rpkm:
            num_good += 1
    return num_good

# Print summary stats
for feature in features:
    my_str = feature + "\t"
    my_str += str(num_sequenced_bases[feature]) + "\t"
    my_str += str(total_bases_sequenced) + "\t"
    my_str += str(100.0*float(num_sequenced_bases[feature])/total_bases_sequenced) + "\t"
    my_str += str(num_covered_bases[feature]) + "\t"
    my_str += str(lengths[feature]) + "\t"
    my_str += str(100.0*float(num_covered_bases[feature])/lengths[feature]) + "\t"
    my_str += str(float(num_sequenced_bases[feature])/num_covered_bases[feature]) + "\t"
    my_str += str(100.0*float( filter_count_RPKM(feature_dists[feature], total_bases_sequenced, 0.1) )/num_covered_bases[feature]) + "\t"
    my_str += str(100.0*float( filter_count_RPKM(feature_dists[feature], total_bases_sequenced, 1.0) )/num_covered_bases[feature]) + "\t"
    my_str += str(100.0*float( filter_count_RPKM(feature_dists[feature], total_bases_sequenced, 10.0) )/num_covered_bases[feature]) + "\t"
    my_str += str(100.0*float( filter_count_RPKM(feature_dists[feature], total_bases_sequenced, 100.0) )/num_covered_bases[feature]) + "\t"
    my_str += str(100.0*float( filter_count_RPKM(feature_dists[feature], total_bases_sequenced, 1000.0) )/num_covered_bases[feature]) + "\t"
    print my_str

# Print distributions to output files
for feature in features:
    outfile = open(output_base_name + '.' + feature, 'w')
    pairs = feature_dists[feature].items()
    pairs.sort()
    for pair in pairs:
        outfile.write( str(pair[0]) + "\t" + str(pair[1]) + "\n" )
    outfile.close()
